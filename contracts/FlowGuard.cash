// FlowGuard Main Covenant
// Enforces spending rules, unlocks, and approvals using Layla CHIPs

pragma cashscript ^0.8.0;

// Import modules
import { Loop } from './loops.cash';
import { BitwiseState } from './bitwise.cash';
import { hasApproval, isSigner, isAllowedSpending } from './functions.cash';

contract FlowGuard(
    // Vault parameters
    bytes20 vaultId,
    int totalDeposit,
    int spendingCap,
    int approvalThreshold,
    
    // Signers (up to 3 for MVP)
    bytes20 signer1,
    bytes20 signer2,
    bytes20 signer3,
    
    // State tracking
    int state,
    
    // Loop parameters
    int cycleDuration,
    int unlockAmount
) {
    // Main unlock function - triggered by Loop
    function unlock(int cycleNumber) {
        require(Loop.isUnlockTime(cycleNumber, cycleDuration));
        require(BitwiseState.isCycleUnlocked(state, cycleNumber) == false);
        
        // Update state to mark cycle as unlocked
        int newState = BitwiseState.setCycleUnlocked(state, cycleNumber);
        
        // Output: return funds with updated state
        bytes lockingBytecode = new LockingBytecodeP2SH(
            vaultId,
            totalDeposit,
            spendingCap,
            approvalThreshold,
            signer1,
            signer2,
            signer3,
            newState,
            cycleDuration,
            unlockAmount
        );
        return new OutputP2SH(lockingBytecode, totalDeposit);
    }
    
    // Proposal creation
    function createProposal(
        bytes20 recipient,
        int amount,
        int proposalId
    ) {
        require(isSigner(tx.sender, signer1, signer2, signer3));
        require(amount <= spendingCap);
        require(BitwiseState.isProposalPending(state, proposalId) == false);
        
        // Update state to mark proposal as pending
        int newState = BitwiseState.setProposalPending(state, proposalId);
        
        // Output: return funds with updated state
        bytes lockingBytecode = new LockingBytecodeP2SH(
            vaultId,
            totalDeposit,
            spendingCap,
            approvalThreshold,
            signer1,
            signer2,
            signer3,
            newState,
            cycleDuration,
            unlockAmount
        );
        return new OutputP2SH(lockingBytecode, totalDeposit);
    }
    
    // Approval function
    function approveProposal(int proposalId) {
        require(isSigner(tx.sender, signer1, signer2, signer3));
        require(BitwiseState.isProposalPending(state, proposalId));
        
        // Check if threshold is met
        int approvalCount = BitwiseState.getApprovalCount(state, proposalId);
        require(approvalCount < approvalThreshold);
        
        // Update approval count
        int newState = BitwiseState.incrementApproval(state, proposalId);
        
        // Output: return funds with updated state
        bytes lockingBytecode = new LockingBytecodeP2SH(
            vaultId,
            totalDeposit,
            spendingCap,
            approvalThreshold,
            signer1,
            signer2,
            signer3,
            newState,
            cycleDuration,
            unlockAmount
        );
        return new OutputP2SH(lockingBytecode, totalDeposit);
    }
    
    // Payout execution
    function executePayout(
        bytes20 recipient,
        int amount,
        int proposalId
    ) {
        require(BitwiseState.isProposalApproved(state, proposalId, approvalThreshold));
        require(isAllowedSpending(amount, spendingCap, state));
        
        // Update state to mark proposal as executed
        int newState = BitwiseState.setProposalExecuted(state, proposalId);
        
        // Output 1: payout to recipient
        bytes recipientLockingBytecode = new LockingBytecodeP2PKH(recipient);
        return new OutputP2PKH(recipientLockingBytecode, amount);
        
        // Output 2: return remaining funds with updated state
        int remainingAmount = totalDeposit - amount;
        bytes lockingBytecode = new LockingBytecodeP2SH(
            vaultId,
            remainingAmount,
            spendingCap,
            approvalThreshold,
            signer1,
            signer2,
            signer3,
            newState,
            cycleDuration,
            unlockAmount
        );
        return new OutputP2SH(lockingBytecode, remainingAmount);
    }
}

